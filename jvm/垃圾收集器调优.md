本节介绍如何调整和调整Garbage-First垃圾收集器（G1 GC）以进行评估，分析和性能。

如“ 垃圾首先垃圾收集器”部分中所述，G1 GC是一个区域化分代垃圾收集器，这意味着Java对象堆（堆）被划分为多个大小相等的区域。启动时，Java虚拟机（JVM）设置区域大小。区域大小可以从1 MB到32 MB不等，具体取决于堆大小。目标是不超过2048个区域。 eden, survivor, 和 old 是这些区域的逻辑集合，并不连续。

G1 GC具有尝试达到的暂停时间目标（软实时）。在年轻系列中，G1 GC会调整其年轻一代（eden和survivor的大小），以达到柔和的实时目标。请参阅章节暂停和停顿时间目标在垃圾-First垃圾收集有关信息，为什么G1 GC需要暂停，以及如何设置暂停时间目标。

在混合收集期间，G1 GC会根据目标混合垃圾收集数量，堆中每个区域中的活动对象百分比以及总体可接受的堆废物百分比，来调整收集的旧区域的数量。

G1 GC通过将活动对象从一个或多个区域集（称为集合集（CSet））增量并行复制到一个或多个不同的新区域中来实现压缩，从而减少了堆碎片。目标是从包含最大可回收空间的那些区域开始，尽可能多地回收堆空间，同时尝试不超过暂停时间目标（首先是垃圾）。

G1 GC使用独立的记忆集（RSets）来将引用跟踪到区域中。独立的RSets可以并行且独立地收集区域，因为仅需扫描区域的RSet来查找对该区域的引用，而不是整个堆的引用。G1 GC使用写后屏障来记录对堆的更改并更新RSets。

## 垃圾收集阶段
除了疏散暂停（请参见分配（疏散）未在垃圾-First垃圾收集）组成该 *stop-the-world（STW）* 年轻和混合垃圾回收的G1 GC还具有平行，同时，和多相刻印次数。G1 GC使用“开始时快照”（SATB）算法，该算法在标记周期开始时从逻辑上对堆中活动对象集进行快照。活动对象集还包括自标记周期开始以来分配的对象。G1 GC标记算法使用预写屏障来记录和标记属于逻辑快照的对象。

## 年轻垃圾收集
G1GC满足来自添加到伊甸园区域集合的区域的大多数分配请求。在年轻的垃圾收集期间，G1GC从前一次垃圾收集中收集伊甸园区域和幸存区域。来自伊甸园和幸存者区域的活动对象被复制或疏散到一组新的区域。特定对象的目标区域取决于该对象的年龄；已经足够老化的对象被疏散到老一代区域(即，它被提升)；否则，该对象被疏散到survivor区域，并且将被包括在下一个年轻或混合垃圾收集的CSET中。

## 混合垃圾收集
成功完成并发标记周期后，G1 GC从执行年轻垃圾收集切换为执行混合垃圾收集。在混合垃圾收集中，G1 GC可以选择将一些旧区域添加到将要收集的eden区域和survivor区域中。所添加的旧区域的确切数量由多个标志控制（请参阅“ 建议”部分中的“为混合垃圾收集器命名”）。在G1 GC收集到足够数量的旧区域（通过多个混合垃圾收集）之后，G1恢复执行新的垃圾收集，直到下一个标记周期完成。

## 标记周期的各个阶段
标记周期分为以下几个阶段：

- 初始标记阶段：G1 GC在此阶段标记根。此阶段由常规（STW）的年轻垃圾回收承载。

- 根区域扫描阶段：G1 GC扫描在初始标记阶段标记的survivor区域，以参考旧一代并标记参考对象。此阶段与应用程序（非STW）同时运行，并且必须在下一个STW年轻垃圾收集开始之前完成。

- 并发标记阶段：G1 GC在整个堆中找到可访问的（活动的）对象。此阶段与应用程序同时发生，并且可以被STW年轻的垃圾回收中断。

- 标记阶段：此阶段是STW收集，有助于完成标记周期。G1 GC耗尽SATB缓冲区，跟踪未访问的活动对象，并执行参考处理。

- 清理阶段：在最后阶段，G1 GC执行记帐和RSet清理的STW操作。在记帐期间，G1 GC会确定完全空闲的区域和混合垃圾收集候选对象。清除阶段在重置并将空闲区域返回到空闲列表时，部分处于并发状态。

## 重要的默认值
G1 GC是具有默认设置的自适应垃圾收集器，使它无需修改即可高效工作。表10-1，“ G1垃圾收集器的重要选项的默认值”列出了Java HotSpot VM（版本24）中的重要选项及其默认值。您可以通过在以下位置输入选项来适应和调整G1 GC以满足应用程序的性能需求。表10-1，“ G1垃圾收集器重要选项的默认值”，其中JVM命令行上的设置已更改。

表10-1 G1垃圾收集器的重要选项的默认值

| 选项和默认值                                  | 选项                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| ```-XX:G1HeapRegionSize=n```                  | 设置G1区域的大小。该值为2的幂，范围为1 MB到32 MB。目标是基于最小的Java堆大小具有大约2048个区域 |
| ```-XX:MaxGCPauseMillis=200```                | 为所需的最大暂停时间设置目标值。默认值为200毫秒。指定的值不适合您的堆大小。 |
| ```-XX:G1NewSizePercent=5```                  | 设置要用作年轻代大小的最小值的堆百分比。默认值为Java堆的5％。脚1 这是一个实验性标志。有关示例，请参见如何解锁实验性VM标志。此设置代替-XX:DefaultMinNewGenPercent设置。 |
| ```-XX:G1MaxNewSizePercent=60 ```             | 设置堆大小的百分比，以用作年轻代大小的最大值。默认值为Java堆的60％。脚注1 这是一个实验性标志。有关示例，请参见如何解锁实验性VM标志。此设置代替-XX:DefaultMaxNewGenPercent设置。 |
| ```-XX:ParallelGCThreads=n ```                | 设置STW工作线程的值。将的值设置n为逻辑处理器的数量。的值与n逻辑处理器的数量相同，最多为8。如果逻辑处理器多于八个，请将n的值设置为逻辑处理器的大约5/8。除较大的SPARC系统外，这在大多数情况下均有效，其中n的值约为逻辑处理器的5/16。 |
| ```-XX:ConcGCThreads=n```                     | 设置平行标记线的数量。设置n为并行垃圾回收线程（ParallelGCThreads）数量的大约1/4。 |
| ```-XX:InitiatingHeapOccupancyPercent=45```   | 设置触发标记周期的Java堆占用阈值。默认占用率是整个Java堆的45％ |
| ```-XX:G1MixedGCLiveThresholdPercent=85```    | 设置要包含在混合垃圾收集周期中的旧区域的占用阈值。默认占用率为85％。脚注1这是一个实验性标志。有关示例，请参见如何解锁实验性VM标志。此设置代替```-XX:G1OldCSetRegionLiveThresholdPercent```设置。 |
| ```-XX:G1HeapWastePercent=5```                | 设置您愿意浪费的堆百分比。当可回收百分比小于堆垃圾百分比时，Java HotSpot VM不会启动混合垃圾回收周期。默认值为5％。脚注1 |
| ```-XX:G1MixedGCCountTarget=8```              | 设置标记周期后混合垃圾回收的目标数量，以收集最多包含G1MixedGCLIveThresholdPercent实时数据的旧区域。默认值为8个混合垃圾回收。混合馆藏的目标是在此目标数量之内。脚注1 |
| ```-XX:G1OldCSetRegionThresholdPercent=10 ``` | 设置在混合垃圾收集周期中要收集的旧区域数的上限。缺省值为Java堆的10％。脚注1 |
| ```-XX:G1ReservePercent=10```                 | 设置保留内存的百分比以使其保持空闲状态，以减少空间溢出的风险。默认值为10％。当增加或减少百分比时，请确保将总Java堆调整为相同的数量。脚注1 |
Footnote1此设置在Java HotSpot VM内部版本23或更早版本中不可用。

## 如何解锁实验性VM标志
要更改实验性标志的值，必须先将其解锁。您可以通过```-XX:+UnlockExperimentalVMOptions```在任何实验性标志之前在命令行上进行显式设置来执行此操作。例如：

``` java -XX:+UnlockExperimentalVMOptions -XX:G1NewSizePercent=10 -XX:G1MaxNewSizePercent=75 G1test.jar ```

## 推荐建议
在评估和微调G1 GC时，请牢记以下建议：

- 年轻一代的大小：避免使用该-Xmn选项或任何其他相关选项（例如）明确设置年轻一代的大小-XX:NewRatio。固定年轻一代的大小会覆盖目标暂停时间目标。

- 暂停时间目标：评估或调整任何垃圾收集时，总会存在延迟与吞吐量之间的权衡。G1 GC是具有统一暂停的增量垃圾收集器，但在应用程序线程上也有更多开销。G1 GC的吞吐量目标是90％的应用时间和10％的垃圾收集时间。将此与Java HotSpot VM并行收集器进行比较。并行收集器的吞吐量目标是99％的应用程序时间和1％的垃圾收集时间。因此，在评估G1 GC的吞吐量时，请放宽暂停时间目标。设置过于激进的目标表示您愿意承担垃圾收集开销的增加，这直接影响了吞吐量。在评估G1 GC的延迟时，您可以设置所需的（软）实时目标，G1 GC会尝试实现它。副作用是吞吐量可能会受到影响。见本节暂停“ 垃圾优先垃圾收集器”中的时间目标以获取更多信息。

-  训练混合垃圾收集：调整混合垃圾收集时，请尝试以下选项。有关这些选项的信息，请参阅“ 重要默认值 ”部分：

```-XX:InitiatingHeapOccupancyPercent：用于更改标记阈值。

-XX:G1MixedGCLiveThresholdPercent和-XX:G1HeapWastePercent：用于更改混合垃圾收集决策。

-XX:G1MixedGCCountTarget和-XX:G1OldCSetRegionThresholdPercent：用于调整旧区域的CSet。
```
## 溢出和耗尽日志消息
当您在日志中看到“内存溢出”或“内存耗尽”消息时，G1 GC没有足够的内存来存储幸存者或升级对象，或两者都没有。Java堆不能，因为它已经达到最大。消息示例：

```924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space exhausted), 0.1957310 secs]

924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space overflow), 0.1957310 secs]
```

要缓解此问题，请尝试以下调整：

- 增加```-XX:G1ReservePercent```选项的值（并相应增加总堆），以增加“至空间”的保留内存量。
- 通过降低的值来更早地开始标记周期 -XX:InitiatingHeapOccupancyPercent.

- 增加```-XX:ConcGCThreads```选项的值以增加并行标记线程的数量。

有关这些选项的说明，请参见“ 重要默认值”部分。

## 大型的对象和巨大的分配
对于G1 GC，任何大于区域大小一半的对象都被视为巨大对象。这样的物体在老一代中直接分配到庞大的区域。这些巨大的区域是一组连续的区域。StartsHumongous标记连续集合的开始并ContinuesHumongous标记集合的继续。

在分配任何大型区域之前，将检查标记阈值，并在必要时启动并发循环。

在清理阶段以及整个垃圾收集周期的标记周期结束时，将释放死掉的巨型对象。

为了减少复制开销，巨大的对象不包括在任何撤离暂停中。完整的垃圾收集周期将庞大的对象压缩到位。

因为StartsHumongous和ContinuesHumongous区域的每个单独集合仅包含一个humongous对象，所以未使用humongous对象的末端与该对象所覆盖的最后一个区域的末端之间的空间。对于刚好大于堆区域大小倍数的对象，未使用的空间可能导致堆碎片化。

如果您看到由于庞大的分配而启动的背对背并发周期，并且如果此类分配使您的上一代分裂了，那么请增加的值，以```-XX:G1HeapRegionSize```使先前的庞大对象不再是庞大的对象，并将遵循常规分配路径。

